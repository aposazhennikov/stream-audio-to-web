# Аудио Стриминг Сервер на Go

Высокопроизводительный сервер для потоковой передачи аудиофайлов в браузер, написанный на Go. Сервер имеет минимальный расход памяти, поддерживает множество форматов аудио и обеспечивает синхронизированное "радио-подобное" воспроизведение для всех подключенных клиентов.

## Возможности

- **Память < 100 МБ** — даже при стриминге треков длительностью в несколько часов
- **Синхронное "настоящее радио"** — все слушатели слышат одинаковый контент в одно и то же время
- **Множество "станций"** — сопоставление URL-путей и независимых директорий (например `/humor`, `/news`)
- **Перезагрузка плейлиста на лету** — добавление или удаление медиафайлов без перезапуска сервера
- **Docker-образ < 20 МБ** — многоэтапная сборка с проверкой работоспособности
- **Поддержка форматов MP3, AAC, OGG**
- **Эффективное использование памяти** благодаря использованию `io.CopyBuffer` и `sync.Pool`
- **Мониторинг производительности** через Prometheus и Sentry
- **Грациозное завершение работы** при получении сигналов
- **Автоматическая обработка прав доступа** — работает даже с файлами, принадлежащими root
- **Опциональное перемешивание треков** — можно включить или отключить
- **Страница статуса с авторизацией** — защищенный доступ к информации о потоках и управлению плеером
- **Управление плеером вручную** — возможность переключать треки вперед и назад через веб-интерфейс
- **Отслеживание истории треков** — для каждой станции доступна история проигранных треков

## Требования

- Go 1.22 или выше
- Для сборки Docker-образа: Docker Engine

## Структура проекта

Проект имеет модульную архитектуру с четким разделением ответственности:

### Основные компоненты

1. **`main.go`** - Основной файл приложения, содержит точку входа, обработку аргументов командной строки и инициализацию всех компонентов.

2. **`audio/`** - Пакет для работы с аудиоданными
   - `streamer.go` - Содержит логику для стриминга аудиофайлов, управляет клиентскими соединениями и буферизацией данных.

3. **`playlist/`** - Пакет для управления плейлистами
   - `playlist.go` - Отвечает за сканирование директорий, отслеживание изменений в файловой системе, перемешивание треков, историю воспроизведения.

4. **`http/`** - Пакет для HTTP-сервера
   - `server.go` - Реализует HTTP-сервер, обрабатывает запросы, управляет потоками и регистрирует маршруты.

5. **`radio/`** - Пакет для управления "радиостанциями"
   - `radio.go` - Связывает плейлисты и аудиостримеры, управляет потоками воспроизведения.

6. **`web/`** - Веб-интерфейс
   - `index.html` - HTML-страница с аудиоплеером и JavaScript для взаимодействия с сервером.

7. **`entrypoint.sh`** - Скрипт для обработки прав доступа к аудиофайлам перед запуском приложения.

### Дополнительные файлы

- `go.mod` / `go.sum` - Файлы управления зависимостями Go
- `Dockerfile` - Инструкции для сборки Docker-образа
- `docker-compose.yml` - Конфигурация для запуска через Docker Compose
- `kubernetes.yaml` - Манифест для развертывания в Kubernetes

### Взаимодействие компонентов

1. `main.go` загружает конфигурацию и инициализирует сервер
2. Для каждого маршрута создается объект `playlist.Playlist`, который сканирует соответствующую директорию
3. Для каждого плейлиста создается `audio.Streamer`, который отвечает за чтение и отправку аудиоданных
4. `radio.RadioStation` связывает плейлисты и стримеры для непрерывного воспроизведения
5. `http.Server` создает HTTP-обработчики для доступа к потокам

## Обработка прав доступа

Приложение автоматически проверяет и корректирует права доступа к аудиофайлам при запуске. Процесс работает следующим образом:

1. При запуске контейнера сначала выполняется `entrypoint.sh` скрипт
2. Скрипт проверяет все смонтированные директории с аудиофайлами
3. Если обнаружены файлы без прав на чтение, скрипт автоматически добавляет необходимые права
4. Это позволяет работать с файлами, принадлежащими root пользователю, без ручной настройки

## Конфигурация

Сервер можно настроить через флаги командной строки или переменные окружения:

| Флаг / ENV            | Назначение                                  | По умолчанию |
|-----------------------|----------------------------------------------|---------|
| `--port` / `PORT`     | Порт HTTP-сервера                           | `8000`   |
| `--audio-dir` / `AUDIO_DIR` | Директория с аудиофайлами по умолчанию | `./audio` |
| `--stream-format` / `STREAM_FORMAT` | Формат потока (mp3, aac, ogg)   | `mp3`   |
| `--bitrate` / `BITRATE` | Целевой битрейт в kbps                    | `128`   |
| `--max-clients` / `MAX_CLIENTS` | Максимальное количество одновременных клиентов | `500` |
| `--log-level` / `LOG_LEVEL` | Уровень логирования (debug, info, warn, error) | `info` |
| `--buffer-size` / `BUFFER_SIZE` | Размер буфера для чтения в байтах  | `65536` (64KB) |
| `--directory-routes` / `DIRECTORY_ROUTES` | JSON строка с сопоставлением маршрутов и директорий | `{}` |
| `--shuffle` / `SHUFFLE` | Включить/отключить перемешивание треков | `false` |
| (нет флага) / `STATUS_PASSWORD` | Пароль для доступа к странице статуса | `1234554321` |

## Мониторинг и наблюдаемость

Сервер предоставляет следующие эндпоинты для мониторинга:

- **/healthz** — мгновенный ответ 200 OK, если сервер работает
- **/readyz** — проверяет свободное место на диске, использование RAM и доступность директорий
- **/metrics** — метрики Prometheus (количество слушателей, переданные байты и т.д.)
- **/status** — защищенная паролем страница со статусом и управлением для всех аудиопотоков

## Запуск приложения

### Сборка из исходников

1. Клонировать репозиторий
```bash
git clone https://github.com/user/stream-audio-to-web.git
cd stream-audio-to-web
```

2. Сборка приложения
```bash
go build -o audio-streamer .
```

3. Запуск с настройками по умолчанию
```bash
./audio-streamer --audio-dir ./audio
```

4. Запуск с несколькими "станциями" из разных директорий
```bash
./audio-streamer --audio-dir ./audio --directory-routes '{"humor":"/home/humor","science":"/home/science"}'
```

При запуске с указанными настройками, сервер создаст следующие маршруты:
- `:8000/` - трансляция аудио из директории `./audio`
- `:8000/humor` - трансляция аудио из директории `/home/humor`
- `:8000/science` - трансляция аудио из директории `/home/science`

При подключении к этим маршрутам в браузере, аудиопоток будет запускаться автоматически.

### Сборка и запуск с Docker

1. Клонировать репозиторий
```bash
git clone https://github.com/user/stream-audio-to-web.git
cd stream-audio-to-web
```

2. Сборка Docker образа
```bash
docker build -t audio-streamer:latest .
```

3. Запустить контейнер с аудио директориями
```bash
docker run -d --name audio-streamer \
  -p 8000:8000 \
  -v /путь/к/аудио:/app/audio \
  -v /путь/к/юмору:/app/humor \
  -v /путь/к/науке:/app/science \
  -e DIRECTORY_ROUTES='{"humor":"/app/humor","science":"/app/science"}' \
  -e SHUFFLE=false \
  -e STATUS_PASSWORD=ваш_пароль \
  audio-streamer:latest
```

> **Примечание**: Контейнер автоматически обрабатывает права доступа к аудиофайлам, поэтому работает даже с файлами, принадлежащими пользователю root.

4. Проверка статуса контейнера
```bash
docker ps
```

5. Просмотр логов
```bash
docker logs audio-streamer
```

6. Остановка контейнера
```bash
docker stop audio-streamer
```

### С Docker Compose

1. Создайте файл `docker-compose.yml`:
```yaml
version: '3.8'

services:
  audio-streamer:
    image: audio-streamer:latest
    # Для работы с файлами, принадлежащими root
    privileged: true
    ports:
      - "8000:8000"
    volumes:
      - ./audio:/app/audio
      - ./humor:/app/humor
      - ./science:/app/science
    environment:
      - STREAM_FORMAT=mp3
      - BITRATE=128
      - MAX_CLIENTS=500
      - LOG_LEVEL=info
      - BUFFER_SIZE=65536
      - DIRECTORY_ROUTES={"humor":"/app/humor","science":"/app/science"}
      - SHUFFLE=false
      - STATUS_PASSWORD=ваш_пароль
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/healthz"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 5s
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 256M
    restart: unless-stopped
```

2. Запуск
```bash
docker-compose up -d
```

3. Просмотр логов
```bash
docker-compose logs -f
```

4. Остановка
```bash
docker-compose down
```

## API и эндпоинты

- **`/streams`** — список всех доступных аудиопотоков в формате JSON
- **`/now-playing`** — информация о текущем треке
- **`/reload-playlist`** — перезагрузка плейлистов
- **`/web`** — веб-интерфейс с аудиоплеерами
- **`/<route>`** — конечная точка для прослушивания аудиопотока
- **`/status`** — защищенная паролем страница статуса потоков с возможностью управления воспроизведением
- **`/next-track/<route>`** — переход к следующему треку для указанного маршрута
- **`/prev-track/<route>`** — переход к предыдущему треку для указанного маршрута

## Страница статуса и управление воспроизведением

Сервер имеет встроенный веб-интерфейс для мониторинга и управления аудиопотоками, доступный по адресу `/status`.

### Возможности страницы статуса:

- **Защищенный доступ** — вход по паролю, задаваемому через переменную окружения `STATUS_PASSWORD`
- **Информация о состоянии** — отображение текущего трека, времени запуска и количества слушателей для каждой станции
- **Управление плеером** — кнопки для переключения треков вперед и назад
- **История треков** — список последних проигранных треков для каждой станции (до 100 треков)
- **Стабильный порядок станций** — станции всегда отображаются в одном и том же порядке (алфавитном)

### Использование страницы статуса:

1. Откройте в браузере `http://сервер:порт/status`
2. Введите пароль (по умолчанию `1234554321` или установленный через `STATUS_PASSWORD`)
3. После авторизации вы увидите список всех зарегистрированных аудиопотоков
4. Для каждого потока доступны:
   - Кнопка "Переключить назад" — перейти к предыдущему треку
   - Кнопка "Переключить вперед" — перейти к следующему треку
   - Кнопка "Показать историю треков" — открыть список последних проигранных треков

## Поддержка разных директорий для разных маршрутов

Сервер поддерживает сопоставление URL-маршрутов и директорий с аудиофайлами. Это позволяет организовать несколько "радиостанций", каждая из которой транслирует свой контент:

```
/home/humor    →  http://localhost:8000/humor    (юмористический контент)
/home/science  →  http://localhost:8000/science  (научный контент)
./audio        →  http://localhost:8000/         (основной контент)
```

Для настройки сопоставления можно использовать:

1. Флаг командной строки:
```bash
./audio-streamer --directory-routes '{"humor":"/home/humor","science":"/home/science"}'
```

2. Переменную окружения:
```bash
export DIRECTORY_ROUTES='{"humor":"/home/humor","science":"/home/science"}'
./audio-streamer
```

3. В Docker:
```bash
docker run -d -p 8000:8000 \
  -v /home/humor:/app/humor \
  -v /home/science:/app/science \
  -e DIRECTORY_ROUTES='{"humor":"/app/humor","science":"/app/science"}' \
  -e SHUFFLE=false \
  -e STATUS_PASSWORD=ваш_пароль \
  audio-streamer:latest
```

## Архитектура

Проект имеет модульную архитектуру с четким разделением обязанностей:

- **audio** — управление аудиопотоками и клиентскими соединениями
- **playlist** — сканирование директорий, управление плейлистами и историей треков
- **http** — HTTP-сервер, обработчики запросов и страница статуса
- **radio** — управление "радиостанциями" и воспроизведением треков

## Производительность

- **RAM < 100 МБ** даже при обслуживании сотен клиентов
- **CPU < 5%** на современных серверах
- **Размер Docker-образа < 20 МБ**
- **Пиковая нагрузка ~1000 параллельных клиентов** (зависит от сервера)

## Лицензия

MIT


# TODO 


- Fix shuffle mode, it doesn't work right now. - NOT DONE ❌


- Check how circle play working, after last audio in playlist should play first one  - DONE ✅

- Check how it's work if we addin new audio to folder, while stream working. - NOT DONE ❌

- Add HEAD requeests for monitoring DONE ✅

- Add routes to switch audio forward/backward(It should be available by curl with specific header, to protect from random internet scanners) - NOT DONE ❌